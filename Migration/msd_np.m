function [avg_dist2] = msd_np(trajectory)% This function will take a trajectory which comes out of process_movie and % calculate the msd.  (it would be nice to vectorize % this program so that it can take a list of trajectories)% It is exactly the same as msd, except this is the no plot (np) versionsteps = length(trajectory)-1;x = trajectory(:,1)';y = trajectory(:,2)';% The loop below cycles through all the possible time increments, and constructs% a matrix which contains all the x differences in the upper triangular portion% of the matrix (not including the main diagonal), and does the same thing for % the y differences.  xd_matr = zeros(steps+1);yd_matr = zeros(steps+1);sh_x = x;sh_y = y; for incr = 1:steps 	sh_x = shift(sh_x,3); 	xd_matr(incr,:) = sh_x - x; 	sh_y = shift(sh_y,3); 	yd_matr(incr,:) = sh_y - y; end% The next section fills in zeros everywhere they're supposed to be.% Currently, there is a bunch of meaningless info in these areas. xd = triu(xd_matr); yd = triu(yd_matr); for k = 1:steps 	xd(k,k) = 0; 	yd(k,k) = 0; end% Now xd and yd are upper triangular matrices which represent% the dx and dy motions of the cell.  The first row has differences% accumulated in one timestep, the second has differences accumulated % in two time steps, etc. x2 = xd.*xd;y2 = yd.*yd;d2 = x2+y2;%d = d2.^(1/2);dist2 = sum(d2');dist2(end) = [];avg_dist2 = dist2./(steps:-1:1);%cmsd = sum(norm_dist)/steps;%figure%plot(avg_dist2);return	